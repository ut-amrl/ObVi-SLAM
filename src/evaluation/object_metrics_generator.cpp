//
// Created by amanda on 2/19/23.
//

#include <base_lib/pose_utils.h>
#include <evaluation/object_evaluation_utils.h>
#include <file_io/cv_file_storage/full_sequence_object_metrics_file_storage_io.h>
#include <file_io/cv_file_storage/output_problem_data_file_storage_io.h>
#include <file_io/cv_file_storage/sequence_file_storage_io.h>
#include <file_io/file_access_utils.h>
#include <file_io/global_object_estimates_io.h>
#include <file_io/pose_3d_io.h>
#include <gflags/gflags.h>
#include <glog/logging.h>
#include <refactoring/types/vslam_basic_types_refactor.h>
#include <refactoring/visualization/ros_visualization.h>
using namespace vslam_types_refactor;
using namespace pose;

DEFINE_string(gt_ellipsoids_file,
              "",
              "File containing the ground truth for the ellipsoids");
DEFINE_string(
    gt_to_bl_extrinsics,
    "",
    "File containing the extrinsic calibration of the frame "
    "that the (pseudo) ground truth outputs are with respect to "
    "relative to the baselink. If the frame for ground truth is the "
    "ouster's frame, for example, this provides the pose of the ouster"
    " relative to the base_link");
DEFINE_string(comparison_alg_est_dir,
              "",
              "Directory containing the trajectories generated by the "
              "algorithm to compare to the (pseudo) ground truth. Within this, "
              "there should be a directory for each bag to evaluate");
DEFINE_string(comparison_alg_to_bl_extrinsics,
              "",
              "File containing the extrinsic calibration of the frame that the "
              "lego-loam outputs are with respect to relative to the baselink. "
              "If the frame for lego-loam is the ouster's frame, for example, "
              "this provides the pose of the ouster relative to the base_link");
DEFINE_string(trajectory_results_dir_suffix,
              "",
              "Directory within the bag-specific directory that contains the "
              "trajectory to evaluate. May be empty if the results are "
              "directly in the sequence directory");
DEFINE_string(
    sequence_file,
    "",
    "File containing the sequence of bags to evaluate the output for. In the "
    "comparison_alg_traj_est_dir, there should be a directory for each bag in "
    "the sequence, prefixed with its 0-indexed number in the sequence. If this "
    "is left blank, a single directory corresponding to one trajectory must be "
    "provided.");
DEFINE_string(
    single_trajectory_eval_base_name,
    "",
    "If specified, sequence_file must not be specified (else sequence_file "
    "parameter must be present). If specified, the trajectory in this "
    "subdirectory under the comparison_alg_traj_est_dir will be evaluated");
DEFINE_string(metrics_out_file,
              "",
              "Name of the file to which to output metrics data to.");
// DEFINE_string(rosbag_files_directory,
//              "",
//              "Directory where the rosbags are stored");
DEFINE_string(param_prefix, "", "Prefix for published topics");

const std::string kIndivObjectsBaseFileName = "ellipsoids.csv";
const std::string kIndivObjectsWithIdsBaseFileName = "ellipsoid_results.json";

FullDOFEllipsoidResults readEllipsoidResultsWithoutId(
    const std::string &objects_file_name) {
  std::vector<file_io::ObjectEst> object_estimates;
  file_io::readObjectEstsFromFile(objects_file_name, object_estimates);

  FullDOFEllipsoidResults obj_results;
  for (size_t obj_idx = 0; obj_idx < object_estimates.size(); obj_idx++) {
    file_io::ObjectEst obj_est = object_estimates[obj_idx];
    FullDOFEllipsoidState<double> state_for_obj(
        Pose3D<double>(
            Position3d<double>(
                obj_est.transl_x_, obj_est.transl_y_, obj_est.transl_z_),
            Eigen::AngleAxisd(Eigen::Quaterniond(obj_est.quat_w_,
                                                 obj_est.quat_x_,
                                                 obj_est.quat_y_,
                                                 obj_est.quat_z_))),
        ObjectDim<double>(obj_est.d_x_, obj_est.d_y_, obj_est.d_z_));
    obj_results[obj_idx] =
        std::make_pair(obj_est.semantic_class_, state_for_obj);
  }
  return obj_results;
}

FullDOFEllipsoidResults readEllipsoidResultsWithId(
    const std::string &objects_file_name) {
  cv::FileStorage obj_in_fs(objects_file_name, cv::FileStorage::READ);
  EllipsoidResults ellipsoid_results_orig_format;
  readEllipsoidResults(objects_file_name, ellipsoid_results_orig_format);

  FullDOFEllipsoidResults ellipsoid_results;
  for (const auto &ellipsoid_result_orig_format :
       ellipsoid_results_orig_format.ellipsoids_) {
    Pose3D<double> full_dof_ellipsoid_pose(
        ellipsoid_result_orig_format.second.second.pose_.transl_,
        Eigen::AngleAxisd(ellipsoid_result_orig_format.second.second.pose_.yaw_,
                          Eigen::Vector3d::UnitZ()));
    ellipsoid_results[ellipsoid_result_orig_format.first] = std::make_pair(
        ellipsoid_result_orig_format.second.first,
        FullDOFEllipsoidState<double>(
            full_dof_ellipsoid_pose,
            ellipsoid_result_orig_format.second.second.dimensions_));
  }
  return ellipsoid_results;
}

FullDOFEllipsoidResults readEllipsoidResults(
    const std::string &indiv_bag_dir_name,
    const std::string &results_dir_suffix,
    const std::string &alg_dir_root) {
  std::vector<std::string> full_paths_for_comparison_object_files;
  std::string comparison_alg_path_suffix = results_dir_suffix;

  if (!comparison_alg_path_suffix.empty()) {
    comparison_alg_path_suffix =
        file_io::ensureDirectoryPathEndsWithSlash(comparison_alg_path_suffix);
  }

  std::string results_dir_name =
      file_io::ensureDirectoryPathEndsWithSlash(
          file_io::ensureDirectoryPathEndsWithSlash(alg_dir_root) +
          indiv_bag_dir_name) +
      comparison_alg_path_suffix;

  std::string labeled_obj_full_path =
      results_dir_name + kIndivObjectsWithIdsBaseFileName;
  std::string unlabeled_obj_full_path =
      results_dir_name + kIndivObjectsBaseFileName;

  if (std::filesystem::exists(labeled_obj_full_path)) {
    return readEllipsoidResultsWithId(labeled_obj_full_path);
  } else if (std::filesystem::exists(unlabeled_obj_full_path)) {
    return readEllipsoidResultsWithoutId(unlabeled_obj_full_path);
  } else {
    LOG(WARNING) << "No ellipsoid results for " << indiv_bag_dir_name;
    return {};
  }
}

FullSequenceObjectMetrics computeMetrics(
    const FullDOFEllipsoidResults &gt_objs,
    const std::vector<FullDOFEllipsoidResults> &est_objs_by_traj,
    const std::shared_ptr<vslam_types_refactor::RosVisualization> &vis_manager =
        nullptr) {
  FullSequenceObjectMetrics full_metrics;

  for (size_t traj_num = 0; traj_num < est_objs_by_traj.size(); traj_num++) {
    SingleTrajectoryObjectMetrics metrics_for_traj;
    FullDOFEllipsoidResults est_objs_for_traj = est_objs_by_traj.at(traj_num);

    std::unordered_map<ObjectId, std::optional<ObjectId>>
        opt_gt_obj_for_est_obj;
    Pose3D<double> est_obj_transformation;
    associateObjectsAndFindTransformation(est_objs_for_traj,
                                          gt_objs,
                                          false,
                                          opt_gt_obj_for_est_obj,
                                          est_obj_transformation);

    FullDOFEllipsoidResults aligned_est_objs;
    adjustObjectFrame(
        est_objs_for_traj, est_obj_transformation, aligned_est_objs);

    if (vis_manager != nullptr) {
      vis_manager->visualizeEllipsoids(
          aligned_est_objs, PlotType::ESTIMATED, false);

      vis_manager->visualizeEllipsoids(
          est_objs_for_traj, PlotType::INITIAL, false);
    }

    std::unordered_map<ObjectId, std::optional<double>> dist_from_gt_by_obj;
    getPositionDistancesList(
        aligned_est_objs, gt_objs, opt_gt_obj_for_est_obj, dist_from_gt_by_obj);

    std::unordered_map<ObjectId, double> iou_per_gt_obj;
    getIoUsForObjects(
        aligned_est_objs, gt_objs, opt_gt_obj_for_est_obj, iou_per_gt_obj);

    double average_pos_deviation = 0;
    size_t associated_est_objs = 0;
    for (const auto &est_obj_dist : dist_from_gt_by_obj) {
      if (est_obj_dist.second.has_value()) {
        associated_est_objs++;
        average_pos_deviation += est_obj_dist.second.value();
      }
    }
    average_pos_deviation /= associated_est_objs;

    double avg_iou = 0;
    for (const auto &iou_for_obj : iou_per_gt_obj) {
      avg_iou += iou_for_obj.second;
    }
    avg_iou /= iou_per_gt_obj.size();

    std::unordered_map<ObjectId, size_t> num_objs_for_gt_objs;
    for (const auto &gt_obj_entry : gt_objs) {
      num_objs_for_gt_objs[gt_obj_entry.first] = 0;
    }

    for (const auto &obj_assignment : opt_gt_obj_for_est_obj) {
      if (obj_assignment.second.has_value()) {
        num_objs_for_gt_objs[obj_assignment.second.value()]++;
      }
    }

    int missed_gt_objs_ = 0;
    size_t assignments_to_gt_objs = 0;
    for (const auto &num_objs_for_gt_obj : num_objs_for_gt_objs) {
      if (num_objs_for_gt_obj.second == 0) {
        missed_gt_objs_++;
      } else {
        assignments_to_gt_objs += num_objs_for_gt_obj.second;
      }
    }
    metrics_for_traj.missed_gt_objs_ = missed_gt_objs_;
    metrics_for_traj.objects_per_gt_obj_ =
        ((double)assignments_to_gt_objs) / (gt_objs.size() - missed_gt_objs_);
    metrics_for_traj.opt_gt_obj_for_est_obj_ = opt_gt_obj_for_est_obj;
    metrics_for_traj.iou_for_gt_obj_ = iou_per_gt_obj;
    metrics_for_traj.pos_diff_for_est_obj_ = dist_from_gt_by_obj;
    metrics_for_traj.average_pos_deviation_ = average_pos_deviation;
    metrics_for_traj.avg_iou_ = avg_iou;

    full_metrics.indiv_trajectory_object_metrics_.emplace_back(
        metrics_for_traj);
  }
  return full_metrics;
}

int main(int argc, char **argv) {
  google::ParseCommandLineFlags(&argc, &argv, false);

  google::InitGoogleLogging(argv[0]);
  FLAGS_logtostderr = true;
  FLAGS_colorlogtostderr = true;

  std::string param_prefix = FLAGS_param_prefix;
  std::string node_prefix = FLAGS_param_prefix;
  if (!param_prefix.empty()) {
    param_prefix = "/" + param_prefix + "/";
    node_prefix += "_";
  }

  ros::init(argc, argv, "a_" + node_prefix + "objects_metrics_generator");
  ros::NodeHandle node_handle;
  std::shared_ptr<RosVisualization> vis_manager =
      std::make_shared<RosVisualization>(
          node_handle, param_prefix, node_prefix);
  ros::Duration(2).sleep();

  if (FLAGS_sequence_file.empty() ==
      FLAGS_single_trajectory_eval_base_name.empty()) {
    LOG(ERROR) << "Exactly one of single_trajectory_eval_base_name (run "
                  "metrics on single bag) and sequence_file (run metrics on "
                  "sequence) can be specified";
    exit(1);
  }

  if (FLAGS_gt_ellipsoids_file.empty()) {
    LOG(ERROR) << "Ground truth ellipsoids file must be provided";
    exit(1);
  }

  if (FLAGS_gt_to_bl_extrinsics.empty()) {
    LOG(ERROR) << "Ground truth ellipsoids file must be provided";
    exit(1);
  }

  if (FLAGS_comparison_alg_est_dir.empty()) {
    LOG(ERROR) << "Comparison algorithm object estimate directory must be "
                  "specified";
    exit(1);
  }

  if (FLAGS_comparison_alg_to_bl_extrinsics.empty()) {
    LOG(ERROR) << "Calibration from frame of approach to compute metrics for "
                  "to base link must be specified";
    exit(1);
  }

  if (FLAGS_metrics_out_file.empty()) {
    LOG(ERROR) << "Metrics output file must be specified";
    exit(1);
  }

  LOG(INFO) << "Reading extrinsics from files";

  Pose3D<double> comparison_traj_frame_rel_base_link;
  std::vector<Pose3D<double>> comparison_traj_extrinsics_contents;
  file_io::readPose3dsFromFile(FLAGS_comparison_alg_to_bl_extrinsics,
                               comparison_traj_extrinsics_contents);
  if (comparison_traj_extrinsics_contents.empty()) {
    LOG(ERROR) << "Comparison approach extrinsics missing";
    exit(1);
  }
  if (comparison_traj_extrinsics_contents.size() > 1) {
    LOG(WARNING) << "Comparison approach extrinsics file contained more than "
                    "one pose. Taking the first";
  }
  comparison_traj_frame_rel_base_link =
      comparison_traj_extrinsics_contents.front();

  Pose3D<double> lego_loam_frame_rel_base_link;
  std::vector<Pose3D<double>> lego_loam_extrinsics_contents;
  file_io::readPose3dsFromFile(FLAGS_gt_to_bl_extrinsics,
                               lego_loam_extrinsics_contents);
  if (lego_loam_extrinsics_contents.empty()) {
    LOG(ERROR) << "LeGO-LOAM extrinsics missing";
    exit(1);
  }
  if (lego_loam_extrinsics_contents.size() > 1) {
    LOG(WARNING) << "Lego loam extrinsics file contained more than one pose. "
                    "Taking the first";
  }
  lego_loam_frame_rel_base_link = lego_loam_extrinsics_contents.front();

  std::vector<std::string> indiv_traj_dir_base_names;
  //  std::vector<std::optional<std::string>> waypoint_file_base_names;
  if (!FLAGS_sequence_file.empty()) {
    SequenceInfo sequence_info;
    readSequenceInfo(FLAGS_sequence_file, sequence_info);
    if (sequence_info.bag_base_names_and_waypoint_files.empty()) {
      LOG(ERROR) << "No bag names in sequence";
      exit(1);
    }
    for (size_t bag_idx = 0;
         bag_idx < sequence_info.bag_base_names_and_waypoint_files.size();
         bag_idx++) {
      indiv_traj_dir_base_names.emplace_back(
          (std::to_string(bag_idx) + "_" +
           sequence_info.bag_base_names_and_waypoint_files[bag_idx]
               .bag_base_name_));
    }
  } else {
    indiv_traj_dir_base_names.emplace_back(
        FLAGS_single_trajectory_eval_base_name);
  }

  std::vector<FullDOFEllipsoidResults> results_for_comparison_alg;
  for (const std::string &indiv_traj_dir_base_name :
       indiv_traj_dir_base_names) {
    FullDOFEllipsoidResults results_for_traj =
        readEllipsoidResults(indiv_traj_dir_base_name,
                             FLAGS_trajectory_results_dir_suffix,
                             FLAGS_comparison_alg_est_dir);
    FullDOFEllipsoidResults results_for_traj_rel_bl;
    adjustObjectFrame(results_for_traj,
                      comparison_traj_frame_rel_base_link,
                      results_for_traj_rel_bl);
    results_for_comparison_alg.emplace_back(results_for_traj_rel_bl);
  }

  FullDOFEllipsoidResults gt_objects_orig_frame =
      readEllipsoidResultsWithoutId(FLAGS_gt_ellipsoids_file);
  FullDOFEllipsoidResults gt_objects_bl_frame;
  adjustObjectFrame(gt_objects_orig_frame,
                    lego_loam_frame_rel_base_link,
                    gt_objects_bl_frame);

  if (vis_manager != nullptr) {
    vis_manager->visualizeEllipsoids(
        gt_objects_bl_frame, PlotType::GROUND_TRUTH, false);

    for (size_t traj_num = 0; traj_num < results_for_comparison_alg.size();
         traj_num++) {
      const FullDOFEllipsoidResults results_for_traj_comparison =
          results_for_comparison_alg.at(traj_num);
      vis_manager->visualizeEllipsoids(
          results_for_traj_comparison, PlotType::INITIAL, false);
      sleep(2);
    }

    vis_manager->visualizeEllipsoids(
        gt_objects_bl_frame, PlotType::GROUND_TRUTH, false);
  }

  FullSequenceObjectMetrics full_metrics = computeMetrics(
      gt_objects_bl_frame, results_for_comparison_alg, vis_manager);
  LOG(INFO) << "Done computing metrics; writing to file " << FLAGS_metrics_out_file;

  writeFullSequenceObjectMetrics(FLAGS_metrics_out_file, full_metrics);
}