//
// Created by amanda on 2/19/23.
//

#include <base_lib/pose_utils.h>
#include <evaluation/evaluation_utils.h>
#include <evaluation/trajectory_interpolation_utils.h>
#include <file_io/cv_file_storage/full_sequence_metrics_file_storage_io.h>
#include <file_io/cv_file_storage/sequence_file_storage_io.h>
#include <file_io/file_access_utils.h>
#include <file_io/pose_3d_io.h>
#include <file_io/pose_3d_with_timestamp_io.h>
#include <file_io/timestamp_and_waypoint_io.h>
#include <gflags/gflags.h>
#include <glog/logging.h>
#include <refactoring/types/vslam_basic_types_refactor.h>
#include <refactoring/types/vslam_types_math_util.h>
using namespace vslam_types_refactor;
using namespace pose;

DEFINE_string(
    interpolated_gt_traj_dir,
    "",
    "Directory containing the trajectories generated by interpolating the "
    "(pseudo) ground truth output to match with the evaluation "
    "algorithm's timestamps. Within this directory, there should be a "
    "directory "
    "for each bag that results should be evaluated for");
DEFINE_string(
    lego_loam_frame_to_bl_extrinsics,
    "",
    "File containing the extrinsic calibration of the frame "
    "that the (pseudo) ground truth outputs are with respect to "
    "relative to the baselink. If the frame for ground truth is the "
    "ouster's frame, for example, this provides the pose of the ouster"
    " relative to the base_link");
DEFINE_string(comparison_alg_traj_est_dir,
              "",
              "Directory containing the trajectories generated by the "
              "algorithm to compare to the (pseudo) ground truth. Within this, "
              "there should be a directory for each bag to evaluate");
DEFINE_string(comparison_alg_to_bl_extrinsics,
              "",
              "File containing the extrinsic calibration of the frame that the "
              "lego-loam outputs are with respect to relative to the baselink. "
              "If the frame for lego-loam is the ouster's frame, for example, "
              "this provides the pose of the ouster relative to the base_link");
DEFINE_string(trajectory_results_dir_suffix,
              "",
              "Directory within the bag-specific directory that contains the "
              "trajectory to evaluate. May be empty if the results are "
              "directly in the sequence directory");
DEFINE_string(
    gt_dir_suffix,
    "",
    "Directory within the bag-specific directory that contains the "
    "interpolated ground truth trajectory. May be empty if the results are "
    "directly in the sequence directory");
DEFINE_string(
    sequence_file,
    "",
    "File containing the sequence of bags to evaluate the output for. In the "
    "comparison_alg_traj_est_dir, there should be a directory for each bag in "
    "the sequence, prefixed with its 0-indexed number in the sequence. If this "
    "is left blank, a single directory corresponding to one trajectory must be "
    "provided.");
DEFINE_string(
    single_trajectory_eval_base_name,
    "",
    "If specified, sequence_file must not be specified (else sequence_file "
    "parameter must be present). If specified, the trajectory in this "
    "subdirectory under the comparison_alg_traj_est_dir will be evaluated");
DEFINE_string(waypoints_files_directory,
              "",
              "Directory where the waypoints files are stored");
DEFINE_string(metrics_out_file,
              "",
              "Name of the file to which to output metrics data to.");
DEFINE_string(rosbag_files_directory,
              "",
              "Directory where the rosbags are stored");
DEFINE_string(odometry_topic, "", "Topic on which odometry is published");

const std::string kIndivTrajectoryBaseFileName = "trajectory.csv";
const std::string kGTIndivTrajectoryBaseFileName =
    "interpolated_lego_loam_poses.csv";

FullSequenceMetrics computeMetrics(
    const std::vector<
        std::vector<std::pair<pose::Timestamp, std::optional<Pose3D<double>>>>>
        &comparison_trajectories_rel_baselink,
    const std::vector<std::vector<std::pair<pose::Timestamp, Pose3D<double>>>>
        &interp_gt_trajectories_rel_baselink,
    const std::vector<std::string> &ros_bag_names,
    const std::string &odom_topic,
    const std::vector<std::vector<WaypointInfo>> &waypoint_info_by_trajectory) {
  FullSequenceMetrics full_metrics;
  std::vector<ATEResults> single_traj_ate_results;

  std::vector<util::BoostHashMap<pose::Timestamp, Pose3D<double>>>
      poses_by_timestamp_by_trajectory;
  for (size_t traj_num = 0;
       traj_num < comparison_trajectories_rel_baselink.size();
       traj_num++) {
    util::BoostHashMap<pose::Timestamp, Pose3D<double>> poses_by_timestamp;
    for (const std::pair<pose::Timestamp, std::optional<Pose3D<double>>>
             &timestamp_and_pose :
         comparison_trajectories_rel_baselink.at(traj_num)) {
      if (timestamp_and_pose.second.has_value()) {
        poses_by_timestamp[timestamp_and_pose.first] =
            timestamp_and_pose.second.value();
      }
    }
    poses_by_timestamp_by_trajectory.emplace_back(poses_by_timestamp);
  }

  // Assumes odom is for base_link
  std::vector<std::vector<std::pair<Timestamp, Pose2d>>>
      odom_poses_by_trajectory;
  for (const std::string &rosbag_name : ros_bag_names) {
    std::vector<std::pair<Timestamp, Pose2d>> odom_poses_for_bag;
    getOdomPoseEsts(rosbag_name, odom_topic, odom_poses_for_bag);
    odom_poses_by_trajectory.emplace_back(odom_poses_for_bag);
  }

  RawWaypointConsistencyResults raw_consistency_results =
      computeWaypointConsistencyResults(waypoint_info_by_trajectory,
                                        comparison_trajectories_rel_baselink,
                                        poses_by_timestamp_by_trajectory,
                                        odom_poses_by_trajectory);

  for (size_t traj_num = 0;
       traj_num < comparison_trajectories_rel_baselink.size();
       traj_num++) {
    std::vector<std::pair<pose::Timestamp, Pose3D<double>>> gt_rel_bl_traj =
        interp_gt_trajectories_rel_baselink[traj_num];
    std::vector<Pose3D<double>> gt_pose_only;
    for (const std::pair<pose::Timestamp, Pose3D<double>> &gt_entry :
         gt_rel_bl_traj) {
      gt_pose_only.emplace_back(gt_entry.second);
    }

    std::vector<std::pair<pose::Timestamp, std::optional<Pose3D<double>>>>
        comparison_traj_rel_bl = comparison_trajectories_rel_baselink[traj_num];
    std::vector<std::optional<Pose3D<double>>> comparison_pose_only;
    for (const std::pair<pose::Timestamp, std::optional<Pose3D<double>>>
             &comparison_entry : comparison_traj_rel_bl) {
      comparison_pose_only.emplace_back(comparison_entry.second);
    }

    std::vector<std::optional<Pose3D<double>>> aligned_comparison_pose;
    alignWithGroundTruth(
        gt_pose_only, comparison_pose_only, aligned_comparison_pose);

    ATEResults traj_ate_results =
        generateATEforRotAndTranslForSyncedAlignedTrajectories(
            aligned_comparison_pose, gt_pose_only);
    TrajectoryMetrics single_traj_metrics;
    single_traj_metrics.ate_results_ = traj_ate_results;
    single_traj_ate_results.emplace_back(traj_ate_results);

    for (const auto &waypoint_with_centroid_dev_by_trajectory :
         raw_consistency_results
             .centroid_deviations_by_waypoint_by_trajectory_) {
      WaypointId waypoint = waypoint_with_centroid_dev_by_trajectory.first;
      std::vector<double> centroid_devs_for_waypoint_for_trajectory =
          waypoint_with_centroid_dev_by_trajectory.second.at(traj_num);
      std::vector<double> orientation_devs_for_trajectory =
          raw_consistency_results
              .orientation_deviations_by_waypoint_by_trajectory_.at(waypoint)
              .at(traj_num);
      single_traj_metrics.waypoint_deviations_[waypoint] =
          std::make_pair(centroid_devs_for_waypoint_for_trajectory,
                         orientation_devs_for_trajectory);
      single_traj_metrics.all_rotation_deviations_.insert(
          single_traj_metrics.all_rotation_deviations_.end(),
          orientation_devs_for_trajectory.begin(),
          orientation_devs_for_trajectory.end());
      single_traj_metrics.all_translation_deviations_.insert(
          single_traj_metrics.all_translation_deviations_.end(),
          centroid_devs_for_waypoint_for_trajectory.begin(),
          centroid_devs_for_waypoint_for_trajectory.end());
    }

    full_metrics.indiv_trajectory_metrics_.emplace_back(single_traj_metrics);
  }

  TrajectoryMetrics sequence_results;
  sequence_results.ate_results_ =
      combineSingleTrajectoryResults(single_traj_ate_results);
  for (const TrajectoryMetrics &single_traj_metrics :
       full_metrics.indiv_trajectory_metrics_) {
    sequence_results.all_translation_deviations_.insert(
        sequence_results.all_translation_deviations_.end(),
        single_traj_metrics.all_translation_deviations_.begin(),
        single_traj_metrics.all_translation_deviations_.end());
    sequence_results.all_rotation_deviations_.insert(
        sequence_results.all_rotation_deviations_.end(),
        single_traj_metrics.all_rotation_deviations_.begin(),
        single_traj_metrics.all_rotation_deviations_.end());

    for (const auto &waypoint_and_devs :
         single_traj_metrics.waypoint_deviations_) {
      std::pair<std::vector<double>, std::vector<double>> all_waypoint_devs;
      if (sequence_results.waypoint_deviations_.find(waypoint_and_devs.first) !=
          sequence_results.waypoint_deviations_.end()) {
        all_waypoint_devs =
            sequence_results.waypoint_deviations_.at(waypoint_and_devs.first);
      } else {
        all_waypoint_devs =
            std::make_pair((std::vector<double>){}, (std::vector<double>){});
      }
      std::vector<double> centroid_devs_for_waypoint = all_waypoint_devs.first;
      std::vector<double> orientation_devs_for_waypoint =
          all_waypoint_devs.second;
      centroid_devs_for_waypoint.insert(centroid_devs_for_waypoint.end(),
                                        waypoint_and_devs.second.first.begin(),
                                        waypoint_and_devs.second.first.end());
      orientation_devs_for_waypoint.insert(
          orientation_devs_for_waypoint.end(),
          waypoint_and_devs.second.second.begin(),
          waypoint_and_devs.second.second.end());
      sequence_results.waypoint_deviations_[waypoint_and_devs.first] =
          std::make_pair(centroid_devs_for_waypoint,
                         orientation_devs_for_waypoint);
    }
  }

  full_metrics.sequence_metrics_ = sequence_results;
  return full_metrics;
}

int main(int argc, char **argv) {
  google::ParseCommandLineFlags(&argc, &argv, false);

  google::InitGoogleLogging(argv[0]);
  FLAGS_logtostderr = true;
  FLAGS_colorlogtostderr = true;

  if (FLAGS_sequence_file.empty() ==
      FLAGS_single_trajectory_eval_base_name.empty()) {
    LOG(ERROR) << "Exactly one of single_trajectory_eval_base_name (run "
                  "metrics on single bag) and sequence_file (run metrics on "
                  "sequence) can be specified";
    exit(1);
  }

  if (FLAGS_interpolated_gt_traj_dir.empty()) {
    LOG(ERROR)
        << "Interpolated ground truth trajectory directory must be provided";
    exit(1);
  }

  if (FLAGS_metrics_out_file.empty()) {
    LOG(ERROR) << "Metrics output file must be specified";
    exit(1);
  }

  if (FLAGS_lego_loam_frame_to_bl_extrinsics.empty()) {
    LOG(ERROR) << "LeGO-LOAM to baselink extrinsics file must be specified";
    exit(1);
  }
  if (FLAGS_comparison_alg_traj_est_dir.empty()) {
    LOG(ERROR) << "Comparison algorithm trajectory estimate directory must be "
                  "specified";
    exit(1);
  }
  if (FLAGS_comparison_alg_to_bl_extrinsics.empty()) {
    LOG(ERROR) << "Calibration from frame of approach to compute metrics for "
                  "to base link must be specified";
    exit(1);
  }
  if (FLAGS_rosbag_files_directory.empty()) {
    LOG(ERROR) << "Rosbags file directory required.";
    exit(1);
  }
  if (FLAGS_odometry_topic.empty()) {
    LOG(ERROR) << "Odometry topic must be specified";
    exit(1);
  }

  std::vector<std::string> indiv_traj_dir_base_names;
  std::vector<std::string> rosbag_names;
  std::vector<std::optional<std::string>> waypoint_file_base_names;
  if (!FLAGS_sequence_file.empty()) {
    SequenceInfo sequence_info;
    readSequenceInfo(FLAGS_sequence_file, sequence_info);
    if (sequence_info.bag_base_names_and_waypoint_files.empty()) {
      LOG(ERROR) << "No bag names in sequence";
      exit(1);
    }
    for (size_t bag_idx = 0;
         bag_idx < sequence_info.bag_base_names_and_waypoint_files.size();
         bag_idx++) {
      indiv_traj_dir_base_names.emplace_back(
          (std::to_string(bag_idx) + "_" +
           sequence_info.bag_base_names_and_waypoint_files[bag_idx]
               .bag_base_name_));
      rosbag_names.emplace_back(
          file_io::ensureDirectoryPathEndsWithSlash(
              FLAGS_rosbag_files_directory) +
          sequence_info.bag_base_names_and_waypoint_files[bag_idx]
              .bag_base_name_ +
          file_io::kBagExtension);
      waypoint_file_base_names.emplace_back(
          sequence_info.bag_base_names_and_waypoint_files[bag_idx]
              .optional_waypoint_file_base_name_);
    }
  } else {
    indiv_traj_dir_base_names.emplace_back(
        FLAGS_single_trajectory_eval_base_name);
    rosbag_names.emplace_back(file_io::ensureDirectoryPathEndsWithSlash(
                                  FLAGS_rosbag_files_directory) +
                              FLAGS_single_trajectory_eval_base_name +
                              file_io::kBagExtension);
  }

  std::vector<std::string> full_paths_for_comparison_trajectories;
  std::vector<std::string> full_paths_for_gt_trajectories;
  for (const std::string &indiv_traj_dir_base_name :
       indiv_traj_dir_base_names) {
    std::string comparison_traj_path_suffix =
        FLAGS_trajectory_results_dir_suffix;
    if (!comparison_traj_path_suffix.empty()) {
      comparison_traj_path_suffix = file_io::ensureDirectoryPathEndsWithSlash(
          comparison_traj_path_suffix);
    }

    std::string gt_traj_path_suffix = FLAGS_gt_dir_suffix;
    if (!comparison_traj_path_suffix.empty()) {
      gt_traj_path_suffix =
          file_io::ensureDirectoryPathEndsWithSlash(gt_traj_path_suffix);
    }

    std::string comparison_traj_full_path =
        file_io::ensureDirectoryPathEndsWithSlash(
            file_io::ensureDirectoryPathEndsWithSlash(
                FLAGS_comparison_alg_traj_est_dir) +
            indiv_traj_dir_base_name) +
        comparison_traj_path_suffix + kIndivTrajectoryBaseFileName;
    full_paths_for_comparison_trajectories.emplace_back(
        comparison_traj_full_path);

    std::string gt_traj_full_path =
        file_io::ensureDirectoryPathEndsWithSlash(
            file_io::ensureDirectoryPathEndsWithSlash(
                FLAGS_interpolated_gt_traj_dir) +
            indiv_traj_dir_base_name) +
        gt_traj_path_suffix + kGTIndivTrajectoryBaseFileName;
    full_paths_for_gt_trajectories.emplace_back(gt_traj_full_path);
  }

  std::vector<std::vector<std::pair<pose::Timestamp, Pose3D<double>>>>
      interp_gt_trajectories;
  for (const std::string &interp_gt_file : full_paths_for_gt_trajectories) {
    std::vector<std::pair<pose::Timestamp, Pose3D<double>>> gt_traj;
    file_io::readPose3dsWithTimestampFromFile(interp_gt_file, gt_traj);
    interp_gt_trajectories.emplace_back(gt_traj);
  }

  std::vector<
      std::vector<std::pair<pose::Timestamp, std::optional<Pose3D<double>>>>>
      comparison_trajectories;
  for (const std::string &comparison_traj_file :
       full_paths_for_comparison_trajectories) {
    std::vector<std::pair<pose::Timestamp, std::optional<Pose3D<double>>>>
        comparison_traj;
    file_io::readOptionalPose3dsWithTimestampFromFile(comparison_traj_file,
                                                      comparison_traj);
    comparison_trajectories.emplace_back(comparison_traj);
  }

  Pose3D<double> comparison_traj_frame_rel_base_link;
  std::vector<Pose3D<double>> comparison_traj_extrinsics_contents;
  file_io::readPose3dsFromFile(FLAGS_comparison_alg_to_bl_extrinsics,
                               comparison_traj_extrinsics_contents);
  if (comparison_traj_extrinsics_contents.empty()) {
    LOG(ERROR) << "Comparison approach extrinsics missing";
    exit(1);
  }
  if (comparison_traj_extrinsics_contents.size() > 1) {
    LOG(WARNING) << "Comparison approach extrinsics file contained more than "
                    "one pose. Taking the first";
  }
  comparison_traj_frame_rel_base_link =
      comparison_traj_extrinsics_contents.front();

  Pose3D<double> lego_loam_frame_rel_base_link;
  std::vector<Pose3D<double>> lego_loam_extrinsics_contents;
  file_io::readPose3dsFromFile(FLAGS_lego_loam_frame_to_bl_extrinsics,
                               lego_loam_extrinsics_contents);
  if (lego_loam_extrinsics_contents.empty()) {
    LOG(ERROR) << "LeGO-LOAM extrinsics missing";
    exit(1);
  }
  if (lego_loam_extrinsics_contents.size() > 1) {
    LOG(WARNING) << "Lego loam extrinsics file contained more than one pose. "
                    "Taking the first";
  }
  lego_loam_frame_rel_base_link = lego_loam_extrinsics_contents.front();
  Pose3D<double> bl_rel_gt_frame = poseInverse(lego_loam_frame_rel_base_link);
  Pose3D<double> base_link_rel_comparison_traj_frame =
      poseInverse(comparison_traj_frame_rel_base_link);

  // Read in comparison algorithm trajectories
  // For each, transform using extrinsics
  // For each, shift first pose to origin and transform rest of trajectory
  // accordingly
  std::vector<
      std::vector<std::pair<pose::Timestamp, std::optional<Pose3D<double>>>>>
      comparison_trajectories_rel_baselink;

  for (const std::vector<
           std::pair<pose::Timestamp, std::optional<Pose3D<double>>>>
           &comparison_traj : comparison_trajectories) {
    std::vector<std::pair<pose::Timestamp, std::optional<Pose3D<double>>>>
        comparison_traj_rel_bl;

    for (const std::pair<pose::Timestamp, std::optional<Pose3D<double>>>
             &orig_compare_pos : comparison_traj) {
      std::optional<Pose3D<double>> transformed_pos;
      if (orig_compare_pos.second.has_value()) {
        transformed_pos = combinePoses(orig_compare_pos.second.value(),
                                       base_link_rel_comparison_traj_frame);
      }
      comparison_traj_rel_bl.emplace_back(orig_compare_pos.first,
                                          transformed_pos);
    }

    std::vector<std::pair<pose::Timestamp, std::optional<Pose3D<double>>>>
        comparison_traj_rel_bl_origin_start;

    Pose3D<double> transform_traj_to_origin_with;
    for (const std::pair<pose::Timestamp, std::optional<Pose3D<double>>>
             &pos_rel_bl : comparison_traj_rel_bl) {
      if (pos_rel_bl.second.has_value()) {
        transform_traj_to_origin_with = poseInverse(pos_rel_bl.second.value());
        break;
      }
    }

    for (const std::pair<pose::Timestamp, std::optional<Pose3D<double>>>
             &pos_rel_bl : comparison_traj_rel_bl) {
      std::optional<Pose3D<double>> pose_to_use;
      if (pos_rel_bl.second.has_value()) {
        pose_to_use = combinePoses(transform_traj_to_origin_with,
                                   pos_rel_bl.second.value());
      }
      comparison_traj_rel_bl_origin_start.emplace_back(
          std::make_pair(pos_rel_bl.first, pose_to_use));
    }

    comparison_trajectories_rel_baselink.emplace_back(
        comparison_traj_rel_bl_origin_start);
  }

  // Read in LeGO-LOAM trajectories
  // For each, transform using extrinsics
  // For each, shift first pose to origin and transform rest of trajectory
  // accordingly
  std::vector<std::vector<std::pair<pose::Timestamp, Pose3D<double>>>>
      interp_gt_trajectories_rel_baselink;

  for (const std::vector<std::pair<pose::Timestamp, Pose3D<double>>>
           &interp_gt_traj : interp_gt_trajectories) {
    std::vector<std::pair<pose::Timestamp, Pose3D<double>>>
        interp_gt_traj_rel_bl;

    for (const std::pair<pose::Timestamp, Pose3D<double>> &orig_gt_pos :
         interp_gt_traj) {
      interp_gt_traj_rel_bl.emplace_back(
          orig_gt_pos.first, combinePoses(orig_gt_pos.second, bl_rel_gt_frame));
    }

    std::vector<std::pair<pose::Timestamp, Pose3D<double>>>
        interp_gt_traj_rel_bl_origin_start;

    Pose3D<double> transform_traj_to_origin_with =
        poseInverse(interp_gt_traj_rel_bl.front().second);

    for (const std::pair<pose::Timestamp, Pose3D<double>> &gt_rel_bl :
         interp_gt_traj_rel_bl) {
      interp_gt_traj_rel_bl_origin_start.emplace_back(std::make_pair(
          gt_rel_bl.first,
          combinePoses(transform_traj_to_origin_with, gt_rel_bl.second)));
    }
    interp_gt_trajectories_rel_baselink.emplace_back(
        interp_gt_traj_rel_bl_origin_start);
  }

  std::vector<std::vector<WaypointInfo>> waypoint_info_by_trajectory;
  bool waypoints_not_provided = true;
  if ((!FLAGS_sequence_file.empty()) &&
      (!FLAGS_waypoints_files_directory.empty())) {
    waypoints_not_provided = false;
  }
  if (waypoints_not_provided) {
    waypoint_info_by_trajectory.resize(
        comparison_trajectories_rel_baselink.size());
  } else {
    for (const std::optional<std::string> &waypoint_file_base_name :
         waypoint_file_base_names) {
      if (waypoint_file_base_name.has_value()) {
        std::string full_waypoint_file_name =
            file_io::ensureDirectoryPathEndsWithSlash(
                FLAGS_waypoints_files_directory) +
            waypoint_file_base_name.value() + file_io::kCsvExtension;
        std::vector<WaypointInfo> waypoint_info_for_traj;
        file_io::readWaypointInfosFromFile(full_waypoint_file_name,
                                           waypoint_info_for_traj);
        waypoint_info_by_trajectory.emplace_back(waypoint_info_for_traj);
      } else {
        waypoint_info_by_trajectory.emplace_back((std::vector<WaypointInfo>){});
      }
    }
  }
  FullSequenceMetrics full_metrics =
      computeMetrics(comparison_trajectories_rel_baselink,
                     interp_gt_trajectories_rel_baselink,
                     rosbag_names,
                     FLAGS_odometry_topic,
                     waypoint_info_by_trajectory);

  writeFullSequenceMetrics(FLAGS_metrics_out_file, full_metrics);
}