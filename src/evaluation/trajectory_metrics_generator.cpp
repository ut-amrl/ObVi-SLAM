//
// Created by amanda on 2/19/23.
//

#include <base_lib/pose_utils.h>
#include <evaluation/evaluation_utils.h>
#include <file_io/cv_file_storage/full_sequence_metrics_file_storage_io.h>
#include <file_io/cv_file_storage/sequence_file_storage_io.h>
#include <file_io/file_access_utils.h>
#include <file_io/pose_3d_io.h>
#include <file_io/pose_3d_with_timestamp_io.h>
#include <gflags/gflags.h>
#include <glog/logging.h>
#include <refactoring/types/vslam_basic_types_refactor.h>
#include <refactoring/types/vslam_types_math_util.h>
using namespace vslam_types_refactor;

DEFINE_string(
    interpolated_gt_traj_dir,
    "",
    "Directory containing the trajectories generated by interpolating the "
    "(pseudo) ground truth output to match with the evaluation "
    "algorithm's timestamps. Within this directory, there should be a "
    "directory "
    "for each bag that results should be evaluated for");
DEFINE_string(
    lego_loam_frame_to_bl_extrinsics,
    "",
    "File containing the extrinsic calibration of the frame "
    "that the (pseudo) ground truth outputs are with respect to "
    "relative to the baselink. If the frame for ground truth is the "
    "ouster's frame, for example, this provides the pose of the ouster"
    " relative to the base_link");
DEFINE_string(comparison_alg_traj_est_dir,
              "",
              "Directory containing the trajectories generated by the "
              "algorithm to compare to the (pseudo) ground truth. Within this, "
              "there should be a directory for each bag to evaluate");
DEFINE_string(comparison_alg_to_bl_extrinsics,
              "",
              "File containing the extrinsic calibration of the frame that the "
              "lego-loam outputs are with respect to relative to the baselink. "
              "If the frame for lego-loam is the ouster's frame, for example, "
              "this provides the pose of the ouster relative to the base_link");
DEFINE_string(trajectory_results_dir_suffix,
              "",
              "Directory within the bag-specific directory that contains the "
              "trajectory to evaluate. May be empty if the results are "
              "directly in the sequence directory");
DEFINE_string(
    gt_dir_suffix,
    "",
    "Directory within the bag-specific directory that contains the "
    "interpolated ground truth trajectory. May be empty if the results are "
    "directly in the sequence directory");
DEFINE_string(
    sequence_file,
    "",
    "File containing the sequence of bags to evaluate the output for. In the "
    "comparison_alg_traj_est_dir, there should be a directory for each bag in "
    "the sequence, prefixed with its 0-indexed number in the sequence. If this "
    "is left blank, a single directory corresponding to one trajectory must be "
    "provided.");
DEFINE_string(
    single_trajectory_eval_base_name,
    "",
    "If specified, sequence_file must not be specified (else sequence_file "
    "parameter must be present). If specified, the trajectory in this "
    "subdirectory under the comparison_alg_traj_est_dir will be evaluated");

DEFINE_string(metrics_out_file,
              "",
              "Name of the file to which to output metrics data to.");

// TODO Add waypoints file (waypoints by timestamp)

const std::string kIndivTrajectoryBaseFileName = "trajectory.csv";
const std::string kGTIndivTrajectoryBaseFileName = "interpolated_lego_loam_poses.csv";

FullSequenceMetrics computeMetrics(
    const std::vector<
        std::vector<std::pair<pose::Timestamp, std::optional<Pose3D<double>>>>>
        &comparison_trajectories_rel_baselink,
    const std::vector<std::vector<std::pair<pose::Timestamp, Pose3D<double>>>>
        &interp_gt_trajectories_rel_baselink) {  // TODO modify to take in
                                                 // waypoint info

  FullSequenceMetrics full_metrics;
  std::vector<ATEResults> single_traj_ate_results;
  for (size_t traj_num = 0;
       traj_num < comparison_trajectories_rel_baselink.size();
       traj_num++) {
    std::vector<std::pair<pose::Timestamp, Pose3D<double>>> gt_rel_bl_traj =
        interp_gt_trajectories_rel_baselink[traj_num];
    std::vector<Pose3D<double>> gt_pose_only;
    for (const std::pair<pose::Timestamp, Pose3D<double>> &gt_entry :
         gt_rel_bl_traj) {
      gt_pose_only.emplace_back(gt_entry.second);
    }

    std::vector<std::pair<pose::Timestamp, std::optional<Pose3D<double>>>>
        comparison_traj_rel_bl = comparison_trajectories_rel_baselink[traj_num];
    std::vector<std::optional<Pose3D<double>>> comparison_pose_only;
    for (const std::pair<pose::Timestamp, std::optional<Pose3D<double>>>
             &comparison_entry : comparison_traj_rel_bl) {
      comparison_pose_only.emplace_back(comparison_entry.second);
    }

    ATEResults traj_ate_results =
        generateATEforRotAndTranslForSyncedAlignedTrajectories(
            comparison_pose_only, gt_pose_only);
    TrajectoryMetrics single_traj_metrics;
    single_traj_metrics.ate_results_ = traj_ate_results;
    single_traj_ate_results.emplace_back(traj_ate_results);
    full_metrics.indiv_trajectory_metrics_.emplace_back(single_traj_metrics);
  }

  // TODO compute waypoint consistency here

  TrajectoryMetrics sequence_results;
  sequence_results.ate_results_ =
      combineSingleTrajectoryResults(single_traj_ate_results);

  full_metrics.sequence_metrics_ = sequence_results;
  return full_metrics;
}

int main(int argc, char **argv) {
  google::ParseCommandLineFlags(&argc, &argv, false);

  google::InitGoogleLogging(argv[0]);
  FLAGS_logtostderr = true;
  FLAGS_colorlogtostderr = true;

  if (FLAGS_sequence_file.empty() ==
      FLAGS_single_trajectory_eval_base_name.empty()) {
    LOG(ERROR) << "Exactly one of single_trajectory_eval_base_name (run "
                  "metrics on single bag) and sequence_file (run metrics on "
                  "sequence) can be specified";
    exit(1);
  }

  if (FLAGS_interpolated_gt_traj_dir.empty()) {
    LOG(ERROR)
        << "Interpolated ground truth trajectory directory must be provided";
    exit(1);
  }

  if (FLAGS_metrics_out_file.empty()) {
    LOG(ERROR) << "Metrics output file must be specified";
    exit(1);
  }

  if (FLAGS_lego_loam_frame_to_bl_extrinsics.empty()) {
    LOG(ERROR) << "LeGO-LOAM to baselink extrinsics file must be specified";
    exit(1);
  }
  if (FLAGS_comparison_alg_traj_est_dir.empty()) {
    LOG(ERROR) << "Comparison algorithm trajectory estimate directory must be "
                  "specified";
    exit(1);
  }
  if (FLAGS_comparison_alg_to_bl_extrinsics.empty()) {
    LOG(ERROR) << "Calibration from frame of approach to compute metrics for "
                  "to base link must be specified";
    exit(1);
  }

  std::vector<std::string> indiv_traj_dir_base_names;
  if (!FLAGS_sequence_file.empty()) {
    SequenceInfo sequence_info;
    readSequenceInfo(FLAGS_sequence_file, sequence_info);
    if (sequence_info.bag_base_names_.empty()) {
      LOG(ERROR) << "No bag names in sequence";
      exit(1);
    }
    for (size_t bag_idx = 0; bag_idx < sequence_info.bag_base_names_.size();
         bag_idx++) {
      indiv_traj_dir_base_names.emplace_back(
          (std::to_string(bag_idx) + "_" +
           sequence_info.bag_base_names_[bag_idx]));
    }
  } else {
    indiv_traj_dir_base_names.emplace_back(
        FLAGS_single_trajectory_eval_base_name);
  }

  std::vector<std::string> full_paths_for_comparison_trajectories;
  std::vector<std::string> full_paths_for_gt_trajectories;
  for (const std::string &indiv_traj_dir_base_name :
       indiv_traj_dir_base_names) {
    std::string comparison_traj_path_suffix =
        FLAGS_trajectory_results_dir_suffix;
    if (!comparison_traj_path_suffix.empty()) {
      comparison_traj_path_suffix = file_io::ensureDirectoryPathEndsWithSlash(
          comparison_traj_path_suffix);
    }

    std::string gt_traj_path_suffix = FLAGS_gt_dir_suffix;
    if (!comparison_traj_path_suffix.empty()) {
      gt_traj_path_suffix =
          file_io::ensureDirectoryPathEndsWithSlash(gt_traj_path_suffix);
    }
    std::string comparison_traj_full_path =
        file_io::ensureDirectoryPathEndsWithSlash(
            file_io::ensureDirectoryPathEndsWithSlash(
                FLAGS_comparison_alg_traj_est_dir) +
            indiv_traj_dir_base_name) +
        comparison_traj_path_suffix + kIndivTrajectoryBaseFileName;
    full_paths_for_comparison_trajectories.emplace_back(
        comparison_traj_full_path);

    std::string gt_traj_full_path =
        file_io::ensureDirectoryPathEndsWithSlash(
            file_io::ensureDirectoryPathEndsWithSlash(
                FLAGS_interpolated_gt_traj_dir) +
            indiv_traj_dir_base_name) +
        gt_traj_path_suffix + kGTIndivTrajectoryBaseFileName;
    full_paths_for_gt_trajectories.emplace_back(gt_traj_full_path);
  }

  std::vector<std::vector<std::pair<pose::Timestamp, Pose3D<double>>>>
      interp_gt_trajectories;
  for (const std::string &interp_gt_file : full_paths_for_gt_trajectories) {
    std::vector<std::pair<pose::Timestamp, Pose3D<double>>> gt_traj;
    file_io::readPose3dsWithTimestampFromFile(interp_gt_file, gt_traj);
    interp_gt_trajectories.emplace_back(gt_traj);
  }

  std::vector<
      std::vector<std::pair<pose::Timestamp, std::optional<Pose3D<double>>>>>
      comparison_trajectories;
  for (const std::string &comparison_traj_file :
       full_paths_for_comparison_trajectories) {
    std::vector<std::pair<pose::Timestamp, std::optional<Pose3D<double>>>>
        comparison_traj;
    file_io::readOptionalPose3dsWithTimestampFromFile(comparison_traj_file,
                                                      comparison_traj);
    comparison_trajectories.emplace_back(comparison_traj);
  }

  Pose3D<double> comparison_traj_frame_rel_base_link;
  std::vector<Pose3D<double>> comparison_traj_extrinsics_contents;
  file_io::readPose3dsFromFile(FLAGS_comparison_alg_to_bl_extrinsics,
                               comparison_traj_extrinsics_contents);
  if (comparison_traj_extrinsics_contents.empty()) {
    LOG(ERROR) << "Comparison approach extrinsics missing";
    exit(1);
  }
  if (comparison_traj_extrinsics_contents.size() > 1) {
    LOG(WARNING) << "Comparison approach extrinsics file contained more than "
                    "one pose. Taking the first";
  }
  comparison_traj_frame_rel_base_link =
      comparison_traj_extrinsics_contents.front();

  Pose3D<double> lego_loam_frame_rel_base_link;
  std::vector<Pose3D<double>> lego_loam_extrinsics_contents;
  file_io::readPose3dsFromFile(FLAGS_lego_loam_frame_to_bl_extrinsics,
                               lego_loam_extrinsics_contents);
  if (lego_loam_extrinsics_contents.empty()) {
    LOG(ERROR) << "LeGO-LOAM extrinsics missing";
    exit(1);
  }
  if (lego_loam_extrinsics_contents.size() > 1) {
    LOG(WARNING) << "Lego loam extrinsics file contained more than one pose. "
                    "Taking the first";
  }
  lego_loam_frame_rel_base_link = lego_loam_extrinsics_contents.front();
  Pose3D<double> bl_rel_gt_frame = poseInverse(lego_loam_frame_rel_base_link);
  Pose3D<double> base_link_rel_comparison_traj_frame =
      poseInverse(comparison_traj_frame_rel_base_link);

  // Read in comparison algorithm trajectories
  // For each, transform using extrinsics
  // For each, shift first pose to origin and transform rest of trajectory
  // accordingly
  std::vector<
      std::vector<std::pair<pose::Timestamp, std::optional<Pose3D<double>>>>>
      comparison_trajectories_rel_baselink;

  for (const std::vector<
           std::pair<pose::Timestamp, std::optional<Pose3D<double>>>>
           &comparison_traj : comparison_trajectories) {
    std::vector<std::pair<pose::Timestamp, std::optional<Pose3D<double>>>>
        comparison_traj_rel_bl;

    for (const std::pair<pose::Timestamp, std::optional<Pose3D<double>>>
             &orig_compare_pos : comparison_traj) {
      std::optional<Pose3D<double>> transformed_pos;
      if (orig_compare_pos.second.has_value()) {
        transformed_pos = combinePoses(orig_compare_pos.second.value(),
                                       base_link_rel_comparison_traj_frame);
      }
      comparison_traj_rel_bl.emplace_back(orig_compare_pos.first,
                                          transformed_pos);
    }

    std::vector<std::pair<pose::Timestamp, std::optional<Pose3D<double>>>>
        coomparison_traj_rel_bl_origin_start;

    Pose3D<double> transform_traj_to_origin_with;
    for (const std::pair<pose::Timestamp, std::optional<Pose3D<double>>>
             &pos_rel_bl : comparison_traj_rel_bl) {
      if (pos_rel_bl.second.has_value()) {
        transform_traj_to_origin_with = poseInverse(pos_rel_bl.second.value());
        break;
      }
    }

    for (const std::pair<pose::Timestamp, std::optional<Pose3D<double>>>
             &pos_rel_bl : comparison_traj_rel_bl) {
      std::optional<Pose3D<double>> pose_to_use;
      if (pos_rel_bl.second.has_value()) {
        pose_to_use = combinePoses(transform_traj_to_origin_with,
                                   pos_rel_bl.second.value());
      }
      coomparison_traj_rel_bl_origin_start.emplace_back(
          std::make_pair(pos_rel_bl.first, pose_to_use));
    }

    comparison_trajectories_rel_baselink.emplace_back(
        coomparison_traj_rel_bl_origin_start);
  }

  // Read in LeGO-LOAM trajectories
  // For each, transform using extrinsics
  // For each, shift first pose to origin and transform rest of trajectory
  // accordingly
  std::vector<std::vector<std::pair<pose::Timestamp, Pose3D<double>>>>
      interp_gt_trajectories_rel_baselink;

  for (const std::vector<std::pair<pose::Timestamp, Pose3D<double>>>
           &interp_gt_traj : interp_gt_trajectories) {
    std::vector<std::pair<pose::Timestamp, Pose3D<double>>>
        interp_gt_traj_rel_bl;

    for (const std::pair<pose::Timestamp, Pose3D<double>> &orig_gt_pos :
         interp_gt_traj) {
      interp_gt_traj_rel_bl.emplace_back(
          orig_gt_pos.first, combinePoses(orig_gt_pos.second, bl_rel_gt_frame));
    }

    std::vector<std::pair<pose::Timestamp, Pose3D<double>>>
        interp_gt_traj_rel_bl_origin_start;

    Pose3D<double> transform_traj_to_origin_with =
        poseInverse(interp_gt_traj_rel_bl.front().second);

    for (const std::pair<pose::Timestamp, Pose3D<double>> &gt_rel_bl :
         interp_gt_traj_rel_bl) {
      interp_gt_traj_rel_bl_origin_start.emplace_back(std::make_pair(
          gt_rel_bl.first,
          combinePoses(transform_traj_to_origin_with, gt_rel_bl.second)));
    }
    interp_gt_trajectories_rel_baselink.emplace_back(
        interp_gt_traj_rel_bl_origin_start);
  }

  FullSequenceMetrics full_metrics =
      computeMetrics(comparison_trajectories_rel_baselink,
                     interp_gt_trajectories_rel_baselink);

  writeFullSequenceMetrics(FLAGS_metrics_out_file, full_metrics);

}